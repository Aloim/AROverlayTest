"""
Gesture recognizer for DesktopWebcamHandtracker.

Classifies hand poses into 7 distinct gestures:
- pinch: Thumb and index finger touching
- fist: All fingers curled
- point: Index finger extended, others curled
- palm: All fingers extended
- thumbsUp: Thumb extended upward, fingers curled
- swipeUp: Upward hand movement
- swipeDown: Downward hand movement
"""

import math
from collections import deque
from dataclasses import dataclass
from enum import Enum, auto
from typing import Optional

import numpy as np

from logger import get_logger
from config import GestureThresholds, SWIPE_WINDOW_SIZE, FINGER_EXTENSION_MARGIN, FIST_EXTENSION_MARGIN
from hand_detector import HandLandmarks, Landmark, LandmarkIndex, distance_2d

logger = get_logger("GestureRecognizer")


class GestureType(Enum):
    """Enumeration of supported gesture types."""
    NONE = auto()
    PINCH = auto()
    FIST = auto()
    POINT = auto()
    PALM = auto()
    THUMBS_UP = auto()
    SWIPE_UP = auto()
    SWIPE_DOWN = auto()
    # Multi-tap gestures (generated by state machine, not raw detection)
    DOUBLE_PINCH = auto()
    TRIPLE_PINCH = auto()


# Map enum to string names (matching profile format)
GESTURE_NAMES: dict[GestureType, str] = {
    GestureType.NONE: "none",
    GestureType.PINCH: "pinch",
    GestureType.FIST: "fist",
    GestureType.POINT: "point",
    GestureType.PALM: "palm",
    GestureType.THUMBS_UP: "thumbsUp",
    GestureType.SWIPE_UP: "swipeUp",
    GestureType.SWIPE_DOWN: "swipeDown",
    GestureType.DOUBLE_PINCH: "doublePinch",
    GestureType.TRIPLE_PINCH: "triplePinch",
}


@dataclass
class GestureResult:
    """Result of gesture recognition."""
    gesture: GestureType
    confidence: float
    cursor_position: Optional[tuple[float, float]] = None  # (x, y) normalized

    @property
    def name(self) -> str:
        """Get gesture name as string."""
        return GESTURE_NAMES.get(self.gesture, "none")


class GestureRecognizer:
    """
    Recognizes hand gestures from landmark data.

    Supports 7 gestures:
    - Static: pinch, fist, point, palm, thumbsUp
    - Dynamic: swipeUp, swipeDown (based on movement)
    """

    def __init__(self, thresholds: Optional[GestureThresholds] = None):
        """
        Initialize gesture recognizer.

        Args:
            thresholds: Custom gesture thresholds, or None for defaults.
        """
        self.thresholds = thresholds or GestureThresholds()

        # Position history for swipe detection
        self._position_history: deque[tuple[float, float]] = deque(
            maxlen=SWIPE_WINDOW_SIZE
        )

        self._last_gesture = GestureType.NONE
        self._frame_count = 0

        logger.debug("GestureRecognizer initialized")

    def recognize(self, landmarks: HandLandmarks) -> GestureResult:
        """
        Recognize gesture from hand landmarks.

        Args:
            landmarks: Detected hand landmarks.

        Returns:
            GestureResult with detected gesture and confidence.
        """
        self._frame_count += 1

        # Get cursor position (index finger tip or palm center)
        cursor_pos = self._get_cursor_position(landmarks)

        # Update position history for swipe detection
        self._position_history.append(cursor_pos)

        # Check for dynamic gestures first (swipes)
        swipe_result = self._detect_swipe(landmarks)
        if swipe_result is not None:
            self._last_gesture = swipe_result.gesture
            return GestureResult(
                gesture=swipe_result.gesture,
                confidence=swipe_result.confidence,
                cursor_position=cursor_pos
            )

        # Check static gestures in priority order
        gesture, confidence = self._classify_static_gesture(landmarks)

        self._last_gesture = gesture

        return GestureResult(
            gesture=gesture,
            confidence=confidence,
            cursor_position=cursor_pos
        )

    def _get_cursor_position(self, landmarks: HandLandmarks) -> tuple[float, float]:
        """
        Get cursor position from landmarks.

        Uses index finger tip for pointing gestures.

        Args:
            landmarks: Hand landmarks.

        Returns:
            (x, y) normalized cursor position.
        """
        # Use index finger tip as cursor position
        index_tip = landmarks.index_tip
        return (index_tip.x, index_tip.y)

    def _classify_static_gesture(
        self, landmarks: HandLandmarks
    ) -> tuple[GestureType, float]:
        """
        Classify static hand pose.

        Args:
            landmarks: Hand landmarks.

        Returns:
            Tuple of (gesture type, confidence).
        """
        # Calculate finger states
        finger_extended = self._get_finger_extended_states(landmarks)
        thumb_up, index_up, middle_up, ring_up, pinky_up = finger_extended
        num_extended = sum([index_up, middle_up, ring_up, pinky_up])

        # Calculate pinch distance (used for both pinch and fist detection)
        pinch_dist = distance_2d(landmarks.thumb_tip, landmarks.index_tip)

        # Check pinch first (highest priority for interaction)
        if pinch_dist < self.thresholds.pinch_distance:
            confidence = 1.0 - (pinch_dist / self.thresholds.pinch_distance)
            return (GestureType.PINCH, min(1.0, confidence))

        # Palm: All fingers extended
        if num_extended >= 4:
            return (GestureType.PALM, 0.9)

        # Point: Index extended, very tolerant of noisy landmarks
        # Only require index up and ring/pinky down (middle can be either)
        if index_up and not ring_up and not pinky_up:
            return (GestureType.POINT, 0.9)

        # Thumbs up: Thumb extended, others curled
        if thumb_up and num_extended == 0:
            # Check if thumb is roughly vertical
            thumb_angle = self._get_thumb_angle(landmarks)
            if thumb_angle < self.thresholds.thumbs_up_angle:
                return (GestureType.THUMBS_UP, 0.85)

        # Fist: All fingers curled AND thumb-index not close (not a pinch)
        # Use more lenient fist-specific margin for easier triggering
        fist_finger_states = self._get_finger_extended_states_for_fist(landmarks)
        fist_thumb_up, fist_index_up, fist_middle_up, fist_ring_up, fist_pinky_up = fist_finger_states
        fist_num_extended = sum([fist_index_up, fist_middle_up, fist_ring_up, fist_pinky_up])

        if fist_num_extended == 0 and not fist_thumb_up and pinch_dist >= self.thresholds.pinch_distance:
            return (GestureType.FIST, 0.9)

        return (GestureType.NONE, 0.0)

    def _get_finger_extended_states(
        self, landmarks: HandLandmarks
    ) -> tuple[bool, bool, bool, bool, bool]:
        """
        Determine which fingers are extended.

        Args:
            landmarks: Hand landmarks.

        Returns:
            Tuple of (thumb, index, middle, ring, pinky) extended states.
        """
        lm = landmarks.landmarks

        # Thumb: Compare tip to IP joint (different axis than other fingers)
        thumb_extended = self._is_thumb_extended(landmarks)

        # Other fingers: Compare tip Y to PIP Y (lower Y = higher on screen)
        # For right hand, extended means tip is above (lower Y) than PIP
        # Use margin to reduce noise sensitivity
        margin = FINGER_EXTENSION_MARGIN
        index_extended = lm[LandmarkIndex.INDEX_TIP].y < lm[LandmarkIndex.INDEX_PIP].y - margin
        middle_extended = lm[LandmarkIndex.MIDDLE_TIP].y < lm[LandmarkIndex.MIDDLE_PIP].y - margin
        ring_extended = lm[LandmarkIndex.RING_TIP].y < lm[LandmarkIndex.RING_PIP].y - margin
        pinky_extended = lm[LandmarkIndex.PINKY_TIP].y < lm[LandmarkIndex.PINKY_PIP].y - margin

        return (thumb_extended, index_extended, middle_extended, ring_extended, pinky_extended)

    def _get_finger_extended_states_for_fist(
        self, landmarks: HandLandmarks
    ) -> tuple[bool, bool, bool, bool, bool]:
        """
        Determine which fingers are extended using fist-specific (more lenient) margin.

        Uses FIST_EXTENSION_MARGIN which is larger than FINGER_EXTENSION_MARGIN,
        making it easier for fingers to be considered "curled" for fist detection.

        Args:
            landmarks: Hand landmarks.

        Returns:
            Tuple of (thumb, index, middle, ring, pinky) extended states.
        """
        lm = landmarks.landmarks

        # Thumb: Same logic as standard check
        thumb_extended = self._is_thumb_extended(landmarks)

        # Other fingers: Use more lenient fist margin
        margin = FIST_EXTENSION_MARGIN
        index_extended = lm[LandmarkIndex.INDEX_TIP].y < lm[LandmarkIndex.INDEX_PIP].y - margin
        middle_extended = lm[LandmarkIndex.MIDDLE_TIP].y < lm[LandmarkIndex.MIDDLE_PIP].y - margin
        ring_extended = lm[LandmarkIndex.RING_TIP].y < lm[LandmarkIndex.RING_PIP].y - margin
        pinky_extended = lm[LandmarkIndex.PINKY_TIP].y < lm[LandmarkIndex.PINKY_PIP].y - margin

        return (thumb_extended, index_extended, middle_extended, ring_extended, pinky_extended)

    def _is_thumb_extended(self, landmarks: HandLandmarks) -> bool:
        """
        Check if thumb is extended.

        Args:
            landmarks: Hand landmarks.

        Returns:
            True if thumb is extended.
        """
        lm = landmarks.landmarks

        # Thumb extends outward from palm
        # Check if tip is further from palm center than IP joint
        thumb_tip = lm[LandmarkIndex.THUMB_TIP]
        thumb_ip = lm[LandmarkIndex.THUMB_IP]
        wrist = lm[LandmarkIndex.WRIST]

        # For right hand, thumb extends left (lower x)
        # For left hand, thumb extends right (higher x)
        is_right_hand = landmarks.handedness == "Right"

        if is_right_hand:
            # Right hand: thumb tip should be further left than IP
            return thumb_tip.x < thumb_ip.x
        else:
            # Left hand: thumb tip should be further right than IP
            return thumb_tip.x > thumb_ip.x

    def _get_thumb_angle(self, landmarks: HandLandmarks) -> float:
        """
        Get angle of thumb from vertical (for thumbs up detection).

        Args:
            landmarks: Hand landmarks.

        Returns:
            Angle in degrees from vertical.
        """
        lm = landmarks.landmarks

        thumb_tip = lm[LandmarkIndex.THUMB_TIP]
        thumb_mcp = lm[LandmarkIndex.THUMB_MCP]

        # Calculate angle from vertical
        dx = thumb_tip.x - thumb_mcp.x
        dy = thumb_tip.y - thumb_mcp.y  # Note: Y increases downward

        # Angle from vertical (0 = straight up)
        angle = abs(math.degrees(math.atan2(abs(dx), -dy)))

        return angle

    def _detect_swipe(self, landmarks: HandLandmarks) -> Optional[GestureResult]:
        """
        Detect swipe gestures from position history.

        Args:
            landmarks: Current hand landmarks.

        Returns:
            GestureResult if swipe detected, None otherwise.
        """
        if len(self._position_history) < SWIPE_WINDOW_SIZE:
            return None

        # Calculate velocity over the window
        positions = list(self._position_history)
        start_pos = positions[0]
        end_pos = positions[-1]

        # Calculate displacement
        dx = end_pos[0] - start_pos[0]
        dy = end_pos[1] - start_pos[1]

        # Calculate total distance traveled
        total_distance = np.sqrt(dx**2 + dy**2)

        if total_distance < self.thresholds.swipe_min_distance:
            return None

        # Calculate velocity (distance / frames normalized)
        velocity = total_distance / (SWIPE_WINDOW_SIZE / 15.0)  # Normalized to 15 frames

        if velocity < self.thresholds.swipe_velocity:
            return None

        # Determine swipe direction
        # Primarily vertical swipes (Y changes more than X)
        if abs(dy) > abs(dx) * 1.5:  # Must be mostly vertical
            confidence = min(1.0, velocity / self.thresholds.swipe_velocity)

            if dy < 0:  # Moving up (Y decreases)
                # Clear history to prevent repeated detection
                self._position_history.clear()
                return GestureResult(
                    gesture=GestureType.SWIPE_UP,
                    confidence=confidence,
                    cursor_position=end_pos
                )
            else:  # Moving down
                self._position_history.clear()
                return GestureResult(
                    gesture=GestureType.SWIPE_DOWN,
                    confidence=confidence,
                    cursor_position=end_pos
                )

        return None

    def reset(self) -> None:
        """Reset recognizer state."""
        self._position_history.clear()
        self._last_gesture = GestureType.NONE
        self._frame_count = 0
